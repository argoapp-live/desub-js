import { Vendor } from '.';
import { ethers } from 'ethers';
import Deployed from './abstracts/deployed';
import { SubscriptionParameters, TokenData, TxResponse } from './interfaces';
export default class SubscriptionContract extends Deployed {
    constructor(vendor: Vendor);
    updateEscrow(escrowAddress: string): Promise<TxResponse>;
    updateStakedToken(stakedTokenAddress: string): Promise<TxResponse>;
    updateDiscountSlabs(discountSlabs: string[], percents: string[]): Promise<TxResponse>;
    enableDiscounts(stakingManagerAddress: string): Promise<TxResponse>;
    disableDiscounts(): Promise<TxResponse>;
    setGovernanceAddress(governanceAddress: string): Promise<TxResponse>;
    setDataContract(dataContractAddress: string): Promise<TxResponse>;
    setManagers(newOwners: string[]): Promise<TxResponse>;
    setNewApprovals(approvalAmount: string): Promise<TxResponse>;
    approveAndDeposit(approvalAmount: string): Promise<TxResponse>;
    gasslessApproval(approvalAmount: string, chainId: number): Promise<TxResponse>;
    gaslessUserAction(a: string, contract: ethers.Contract, erc20: ethers.Contract, biconomy: any): Promise<TxResponse>;
    gaslessUserDeposit(a: string, contract: ethers.Contract, erc20: ethers.Contract, biconomy: any): Promise<TxResponse>;
    gaslessUserWithdraw(a: string, contract: ethers.Contract, erc20: ethers.Contract, biconomy: any): Promise<TxResponse>;
    gasslessMultiTokenApproval(approvalAmount: string, tokenName: string, chainId: number): Promise<TxResponse>;
    sendRawBiconomyERC20Transaction(userAddress: string, abiEncodedFunction: string, rsv: {
        r: string;
        s: string;
        v: number;
    }): Promise<any>;
    getNonceForGaslessERC20(userAddress: string): Promise<number>;
    getUserBalance(userAddress: string): Promise<number>;
    getUserTokenBalance(userAddress: string): Promise<number>;
    userDeposit(amount: string): Promise<TxResponse>;
    userDepositNative(amount: string): Promise<TxResponse>;
    userWithdraw(amount: string): Promise<TxResponse>;
    getUsdPricePrecision(): Promise<any>;
    getManagers(): Promise<Array<string>>;
    getGovernanceAddress(): Promise<string>;
    getEscrow(): Promise<string>;
    checkIfDiscountsEnabled(): Promise<boolean>;
    getStakingManagerAddress(): Promise<string>;
    getStakedTokenAddress(): Promise<string>;
    getDiscountSlabs(): Promise<any>;
    getDataContract(): Promise<any>;
    makeCharge(u: string, d: Array<SubscriptionParameters>, gp?: string): Promise<TxResponse>;
    addTokens(d: Array<TokenData>): Promise<TxResponse>;
    removeTokens(d: Array<string>): Promise<TxResponse>;
    changeUsdPrecision(n: number): Promise<TxResponse>;
    updateParams(params: SubscriptionParameters[]): Promise<TxResponse>;
    deleteParams(paramsToDelete: string[]): Promise<TxResponse>;
    getTotalTokenBalance(): Promise<any>;
    getTotalTokenCharges(): Promise<any>;
    getTotalTokenWithdraws(): Promise<any>;
    setTreasury(treasuryAddress: string): Promise<TxResponse>;
    setCompany(companyAddress: string): Promise<TxResponse>;
    companyWithdraw(amount: string): Promise<TxResponse>;
}
